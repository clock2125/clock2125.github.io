{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/06/17/hello-world/"},{"title":"测试","text":"标题：这是一个测试正文 第一章第一章 第二章第一节第一节 第二节$$\\int^{+\\infty}_{0}\\frac{\\sin{x}}{x}\\mathrm{d}x$$","link":"/2021/06/18/test/"},{"title":"打包和发布自己的Python项目","text":"如何打包自己的python代码并将其发布。 准备工作1. 注册PyPI账号PyPI(The Python Package Index)是一个Python仓库，个人或组织可以在其上发布自己编写的Python软件或第三方库，使用时只需运行pip install &lt;package_name&gt;即可安装对应的库并开始使用。 PyPI官网 2. 安装twine工具1$ python3 -m pip install twine twine用于将打包的项目上传至PyPI仓库。 创建Python项目首先创建一个python项目，本篇教程中以一个packaging_tutorial项目为例进行演示，该项目具有如下的文件结构： 12345packaging_tutorial/└── src/ └── example_package/ ├── __init__.py └── example.py 其中__init__.py为空，但是不可缺失；example.py是包中的模块，包含了该python包的具体实现（如函数functions、类classes、常量constants等等）。作为示例，example.py中的代码简单编写如下： 12def add_one(number): return number+1 使用Pycharm创建该项目的过程如下 新建项目packaging_tutorial 在项目中新建src/目录 在src/目录中新建python包example_package，Pycharm会自动生成__init__.py 在example_package下新建python文件example.py 创建其他文件现在你需要往项目中添加一些打包和发布所需的文件，项目的最终结构如下所示： 12345678910packaging_tutorial/├── LICENSE├── README.md├── pyproject.toml├── setup.py├── src/│ └── example_package/│ ├── __init__.py│ └── example.py└── tests/ 创建tests/目录tests/是将来测试文件的存放位置，暂时是空的。 创建pyproject.tomlpyproject.toml文件告诉项目构建工具（pip和build等）项目的构建需要用到什么，文件内容如下： 123456[build-system]requires = [ &quot;setuptools&gt;=42&quot;, &quot;wheel&quot;]build-backend = &quot;setuptools.build_meta&quot; 创建setup.py本教程采用动态的方式配置元数据，创建setup.py文件，它是setuptools的配置脚本，其中包含了你的包的信息，文件内容如下： 1234567891011121314151617181920212223242526import setuptoolswith open(&quot;README.md&quot;, &quot;r&quot;, encoding=&quot;utf-8&quot;) as fh: long_description = fh.read()setuptools.setup( name=&quot;example-pkg-zts2125&quot;, version=&quot;0.0.1&quot;, author=&quot;zts2125&quot;, author_email=&quot;bitzhong@qq.com&quot;, description=&quot;A small example package&quot;, long_description=long_description, long_description_content_type=&quot;text/markdown&quot;, url=&quot;https://github.com/pypa/sampleproject&quot;, project_urls={ &quot;Bug Tracker&quot;: &quot;https://github.com/pypa/sampleproject/issues&quot;, }, classifiers=[ &quot;Programming Language :: Python :: 3&quot;, &quot;License :: OSI Approved :: MIT License&quot;, &quot;Operating System :: OS Independent&quot;, ], package_dir={&quot;&quot;: &quot;src&quot;}, packages=setuptools.find_packages(where=&quot;src&quot;), python_requires=&quot;&gt;=3.6&quot;,) 其中的setup()函数有许多参数，本例中仅使用了其中的一部分： name是你的包的发布名称，其中只能包含字母、数字、-和_，并且不能和pypi.org上已存在的包名重复。 version是包的版本号。 author和author_email用来标识包的作者。 description是对包的一句话简短介绍。 long_description是对包的详细介绍，并且会展示在这个包的PyPI主页面上。 long_description_content_type是long_description的内容格式，本例中是Markdown。 url是这个包的PyPI主页上Homepage的链接地址，一般是Github地址。 project_urls是展示在PyPI页面上的一系列附加链接，如文档、issues提交等。 classifiers中提供了包的一些附加信息，如开发程度、类别、编程语言等，此处可查看所有的classifier。 package_dir是以包名为键，包的目录为值的一个字典，空的包名表示这是一个”root package”。 packages是需要发布的所有包，可以手动添加，也可以用find_packages()方法自动生成。 python_requires是你的项目所支持的Python版本。 setup()的完整参数及介绍请参考这里。 创建README.mdREADME文件是关于你的python包的介绍，本项目中README内容如下： 123# Example PackageThis is a simple example package. 创建LICENSE在PyPI上，一个规范的包需要包含LICENSE文件，其中包含了包的使用条款。你可以在https://choosealicense.com/上选择你的LICENSE，然后将该LICENSE的文本拷贝至LICENSE文件中即可。本例中选择了MIT License. 123456789101112131415161718192021MIT LicenseCopyright (c) [2021] [bitzhong]Permission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 生成并上传你的包安装build工具： 1$ python3 -m pip install --upgrade build 在pyproject.toml所在目录运行指令： 1$ python3 -m build 该指令会在终端输出很多状态信息，当指令完成时，应当会在项目的dist/目录下生成两个文件： 123dist/ example_package_zts2125-0.0.1-py3-none-any.whl example_package_zts2125-0.0.1.tar.gz 接着运行twine，上传你的包： 1$ twine upload dist/* 命令执行过程中会要求你输入PyPI用户名和密码，按要求输入后等待上传即可 上传成功后，你的包就可以在PyPI上查看了，示例中的包位于https://pypi.org/project/example-pkg-zts2125/0.0.1/. 安装你刚刚上传的包你可以使用pip来安装你的python包。新建一个虚拟环境，用pip安装你的包 1$ pip install example-pkg-zts2125 安装成功后，进入Python交互模式，试试看能否调用包中的方法： 需要注意的是，无论在setup.py中设置的包的name是什么，在安装完成后import的包名都是example_package，即项目中src/目录下的python包名。 如果你想了解关于Python项目的打包和发布的更多信息，请参考PyPA官方文档Packaging Python Projects.","link":"/2021/06/18/%E6%89%93%E5%8C%85%E5%92%8C%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84Python%E9%A1%B9%E7%9B%AE/"},{"title":"DL-Chapter-2","text":"Machine Learning Preface注册Kaggle账号www.kaggle.com Chapter 1: Introduce of Machine/Deep LearningMachine Learning $\\approx$ Looking for Function Regression(回归)：函数输出一个数值 Classification(分类)：从给定的选项选择一个当作输出 Structured Learning：创造一些有结构的东西 第一步 确定模型 第二步 定义Loss函数 绝对值平均误差$e = |y - \\hat{y}|$ 均方误差$e = (y - \\hat{y})^2$ 若$y$和$\\hat{y}$都是概率分布，则通常使用交叉熵(Cross-entropy) 第三步 最优化 Gradient Descent(梯度下降法) $w^1 \\leftarrow w^0 - \\eta\\frac{\\partial L}{\\partial w}|_{w=w^0}$ $(w^1, b^1) \\leftarrow (w^0, b^0) + \\eta(\\frac{\\partial L}{\\partial w}, \\frac{\\partial L}{\\partial b})|_{w=w^0,b=b^0}$ Model的局限性叫做model bias 使用一系列sigmoid函数 $y = c\\frac{1}{1+\\exp(-(b+wx_1))}$ $y = b + \\sum_i c_i sigmoid(b_i +w_ix_1)$ 逼近各种曲线，改进的线性模型 $y = b + \\sum_i c_i sigmoid(b_i+\\sum_j w_{ij}x_j)$ $\\theta = (w_{11},w_{12},\\cdots, w_{nm}, b_1,b_2,\\cdots,b_n, c_1,c_2,\\cdots,c_n,b)$ $g = \\nabla L(\\theta^0)$ $\\theta^1 \\leftarrow \\theta^0 - \\eta g$ $\\blacksquare$","link":"/2021/09/02/Deep-Learning-Chapter-1/"},{"title":"DL-Chapter-2","text":"1 General Guide当觉得结果不好时，首先应该检查模型在training data上的loss。 若在training data上的loss很大，则有Model bias和Optimization两种可能的问题。 1.1 Model Bias model bias指设计的model太过简单，弹性不足，本身并不包含正确的解。 需要重新设计一个更加具有弹性的model。 1.2 Optimization Issue optimization issue指optimization环节使用的方法并无法找出另Loss function最小的参数组合。 判断是Model bias还是Optimization issue的方法： 先跑一个较小的、较浅的Network，甚至用一些不是Deep learning的方法，先看一下这些方法会取得什么水平的loss，如果之后更复杂的模型loss反而更高，那么就是Optimization issue。 如果training data上的loss很小，但testing data上的loss很大，则有可能是Overfitting或mismatch问题。 1.3 Overfitting 在训练集上结果好，在测试集上结果差，则有可能是overfitting问题。 最简单的解决方法是增加训练集（data augmentation，根据对问题的理解，在原有训练集的基础上创造新的训练数据）。 另一个解决方法是给model增加一定的限制，不让他有那么好的弹性，例如： 给模型比较少的参数 使用比较少的feature Early Stopping Dropout 1.4 Mismatch 指训练集和测试集的数据分布不一样导致的测试集上loss低，训练集上loss高。 如果training data和testing data上的loss都足够小，就可以结束了。 2 Local minima &amp; saddle pointlocal minima(局部最小值)和saddle point(鞍点)统称为critical point，训练过程通常都会卡在critical point上。 如何判断训练停在local minima还是saddle point? 对停止处参数$\\theta’$附近的Loss function $L(\\theta)$作如下估计：(类似于泰勒公式)$$L(\\theta) \\approx L(\\theta’) + (\\theta - \\theta’)^{T}g + \\frac{1}{2}(\\theta - \\theta’)^{T}H(\\theta - \\theta’)$$其中$g$是梯度，$H$是Hessian矩阵：$$H_{ij} = \\frac{\\partial^2}{\\partial \\theta_i \\partial \\theta_j}L(\\theta’)$$在$\\theta’$附近，只需关注第三项的符号就能知道函数值和$L(\\theta’)$的大小关系，若第三项恒为正，则$\\theta’$处是local minima，若恒为负则是local maxima，若时正时负则是saddle point，等价于判断矩阵$H$的正定性，故只需求出矩阵$H$的各个特征值，根据正负特征值的个数判断即可。 2.1 在到达鞍点后如何更新设$\\lambda$是Hessian矩阵的一个负的特征值，$u$是属于$\\lambda$的一个特征向量，则$\\theta = \\theta’ + u$.(证明见课程视频)。 从经验上看，local minima并没有那么常见，多数时候训练到一个地方，梯度很小，参数不再更新了，往往是因为卡在了一个saddle point。 3 batch &amp; momentum3.1 回顾 3.2 small batch &amp; large batch小batch：参数更新间隔短 大batch：参数更新间隔长 二者的比较： 更大的batch并不一定需要更长的时间计算gradient：由于GPU具有强大的并行运算的能力，一定范围内的batch size并不会对每次参数更新的时间造成显著的影响，相反小batch下参数更新次数过多反而会导致运行时间更长。 小batch下”Noisy”的更新方式更有利于训练和测试 3.3 momentumMomentum是另外一个有可能可以对抗 Saddle Point或 Local Minima 的技术。 在optimization时模拟了物理世界中的“动量”，每次更新参数时都会考虑上一次参数更新的移动方向和移动步长。 而上图中所有的$m^i$都可以用$g^0, g^1, \\cdots$来表示：$$m^0 = 0\\m^1 = -\\eta g^0\\m^2 = \\lambda m^1 - \\eta g^1 = -\\lambda\\eta g^1 - \\eta g^0\\\\cdots$$ 如图，此时参数$\\theta$就有可能“越过”local minima而到达$L(\\theta)$更小的点。","link":"/2021/09/09/DL-Chapter-2/"}],"tags":[{"name":"hello","slug":"hello","link":"/tags/hello/"},{"name":"test","slug":"test","link":"/tags/test/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"tutorial","slug":"tutorial","link":"/tags/tutorial/"},{"name":"machine learning","slug":"machine-learning","link":"/tags/machine-learning/"},{"name":"deep learning","slug":"deep-learning","link":"/tags/deep-learning/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"},{"name":"hello","slug":"hello","link":"/categories/hello/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"DL-LHY","slug":"学习笔记/DL-LHY","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DL-LHY/"}]}